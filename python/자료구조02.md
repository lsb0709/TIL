# 시간 복잡도 & 빅오 표기법



## 알고리즘의 시간 복잡도



##### 시간 복잡도

- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가르킨다. ==> No!
- 단순하게 알고리즘의 수행 시간을 의미
  - 시간 복잡도가 높다 -> 느린 알고리즘
  - 시간 복잡도가 낮다 -> 빠른 알고리즘



![자료구조02-1](/python/images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B002-1.png)

O(1) : 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)

- 단순계산 -> a + b, 100 * 200

O(logN) : 크기 N인 리스트를 반절씩 순회/탐색

- 이진탐색(Binary Search), 분할정복(Divide & Conquer)

O(N) : 크기 N인 리스트를 순회

- 리스트 순회, 1중 for 문

O(NlogN) : 크기 N인 리스트를 반절씩 탐색 *순회

- 높은 성능의 정렬(Merge/Quick/Heap Sort)

O(N^2) : 크기 M, N인 2중 리스트를 순회

- 2중 리스트 순회, 2중 for 문

O(N^3) : 3중 리스트를 순회

- 3중 리스트 순회, 3중 for문

O(2^N) : 크기 N 집합의 부분 집합

- 크기가 N인 집합의 부분 집합

O(N!) : 크기 N 리스트의 순열

- 크기가 N인 순열



#### 내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있다.



![자료구조02-2](/python/images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B002-2.png)


## 리스트(List)



##### 배열 (Array)

- 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
  - 인덱스(Index)를 통해 데이터에 빠르게 접근
  - 배열의 길이는 변경 불가능 -> 길이를 변경하고 싶다면 새로 생성
  - 데이터 타입은 고정



##### 연결 리스트(Linked List)

- 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조
  - 맨 처음 노드부터 순차적으로 탐색
  - 연결리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리
  - 다양한 데이터 타입 저장
  - 데이터가 메모리에 연속적으로 저장되지 않음

![자료구조02-3](/python/images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B002-3.png)


## 파이썬의 리스트



##### 파이썬 리스트의 메서드

1) .append()
2) .pop()
3) .count()
4) .index()
5) .sort()
6) .reverse()



1. append(원소)

- 리스트 맨 끝에 새로운 원소 삽입

```python
a = [1, 2, 3, 4, 5]
a.append(6)
print(a)
```

[1, 2, 3, 4, 5, 6]

```python
a = [1, 2, 3, 4, 5]
a.append(["a", "b"])
print(a)
```

[1, 2, 3, 4, 5, ['a', 'b']]



2. .pop(인덱스)

- 특정 인덱스에 있는 원소를 삭제 및 반환

```python
a = [1, 2, 3, 4, 5]
b = a.pop()

print(a)
print(b)
```

[1, 2, 3, 4]

5

```python
a = [1, 2, 3, 4, 5]
b = a.pop(2)

print(a)
print(b)
```

[1, 2, 3, 4]

3



3. .count(원소)

- 리스트에서 해당 원소의 개수를 반환

```python
a = [1, 2, 2, 3, 3, 3]
print(a.count(2))
```

2

```python
a = [1, 2, 2, 3, 3, 3]
print(a.count(3))
```

3



4. .index(원소)

- 리스트에서 처음으로 원소가 등장하는 인덱스 반환

```python
a = [1, 2, 3, 2, 5]
print(a.index(2))
```

1

```python
a = [1, 2, 3, 2, 5]
print(a.index(8))
```

ValueError 발생



5. .sort()

- 리스트를 오름차순으로 정렬
- Reverse = True 옵션을 통해 내림차순으로 정렬 가능

```python
a = [5, 2, 4, 0, -1]
a.sort()
print(a)
```

[-1, 0, 2, 4, 5]

```python
a = [5, 2, 4, 0, -1]
a.sort(reverse=True)
print(a)
```

[5, 4, 2, 0, -1]



6. .reverse()

- 리스트의 원소들의 순서를 거꾸로 뒤집기

```python
a = [1, 2, 3, 4, 5]
a.reverse()
print(a)
```

[5, 4, 3, 2, 1]



##### 자주 쓰이는 리스트 관련 내장함수

1. len()
2. sum()
3. max()
4. min()
5. sorted()
6. reversed()



1. len(iterable)

- 리스트의 길이(원소의 개수)를 반환

```python
a = [1, 2, 3, 4, 5]
print(len(a))
```

5



2. sum(iterable)

- 리스트의 모든 원소의 합을 반환

```python
a = [1, 2, 3, 4, 5]
print(sum(a))
```

15



3. max(iterable)

- 리스트의 원소 중 최대값을 반환

```python
a = [1, 2, 3, 4, 5]

print(max(a))
```

5



4. min(iterable)

- 리스트의 원소 중 최소값을 반환

```python
a = [1, 2, 3, 4, 5]
print(min(a))
```

1



5. sorted(iterable)

- 오름차순으로 정렬된 새로운 리스트 반환
- 원본 리스트는 변화 없음

```python
a = [5, 2, -1, 0, 1]
b = sorted(a)
c = sorted(a, reverse=True)

print(a) # 원본
print(b) # 오름차순 정렬
print(c) # 내림차순 정렬
```

[5, 2, -1, 0, 1]

[-1, 0, 1, 2, 5]

[5, 2, 1, 0, -1]



6. reversed(iterable)

- 리스트의 순서를 거꾸로 뒤집은 새로운 객체 반환
- 원본 리스트는 변화 없음

```python
a = [1, 2, 3, 4, 5]
b = reversed(a)
c = list(reversed(a))

print(a) # 원본
print(b) # reversed(a)
print(c) # list(reversed(a))
```

[1, 2, 3, 4, 5]

<list_reverseiterator object at 0x00000298CE25E740>

[5, 4, 3, 2, 1]



## 리스트 컴프리헨션(List Comprehension)

- List Comprehension(리스트 컴프리헨션, 리스트 내포)란 코드 한 줄만으로 새로운 리스트를 만드는 방법이다.



``` python
numbers = []
for i in range(5):
  	numbers.append(i)
print(numbers)
```

[0, 1, 2, 3, 4]



```python
numbers = [i for i in range(5)]
print(numbers)
```

[0, 1, 2, 3, 4]



if문으로 필터링

```python
odd_numbers = [i for i in range(10) if i % 2 == 1]
print(odd_numbers)
```

[1, 3, 5, 7, 9]