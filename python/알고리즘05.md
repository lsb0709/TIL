# 깊이우선탐색 (DFS)



## 그래프 탐색 알고리즘

- 시작 정점에서 간선을 이동할 수 있는 모든 정점을 찾는 알고리즘
  - 깊이우선탐색(Depth-First Search , DFS)
    - 그래프의 깊이를 우선으로 탐색하기 위해 스택의 개념을 활용한다.
  - 너비우선탐색(Breadth-First Search, BFS)
    - 그래프의 너비를 우선으로 탐색하기 위해 큐의 개념을 활용한다.



## 깊이우선탐색(DFS)

- 시작 정점으로부터 갈 수 있는 하위 정점까지 가장 깊게 탐색하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법

#### 특징

- 모든 정점을 방문할 때 유리하다. 따라서 경우의 수, 순열과 조합 문제에서 많이 사용한다.
- 너비우선탐색(BFS)에 비해 코드 구현이 간단하다.
- 단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 너비우선탐색(BFS)이 유리하다



## DFS의 동작 과정

- DFS를 하기 전에, 일단 탐색을 진행할 그래프가 필요하다.
  - 그래프는 인접 행렬 혹은 인접 리스트 방식으로 표현할 수 있다.
- 각 정점을 방문했는지 여부를 판별할 방문 체크 리스트가 필요하다.
  -  사람과 달리 컴퓨터는 각 정점에 방문했는지 여부를 알 수 없다.
  - 따라서 visited 리스트를 따로 선언하여 각 정점을 방문했는지 체크한다.

```python
visited = [False] * n # n은 정점의 개수
```

| 정점 i     | 0     | 1     | 2     | 3     | 4     | 5     | 6     |
| ---------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| Visited[i] | False | False | False | False | False | False | False |

인덱스는 각 정점의 번호

방문한 정점은 True, 방문하지 않은 정점은 False

![알고리즘05-1](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-1.png)

![알고리즘05-2](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-2.png)

![알고리즘05-3](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-3.png)

![알고리즘05-4](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-4.png)

![알고리즘05-5](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-5.png)

![알고리즘05-6](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-6.png)

![알고리즘05-7](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-7.png)

![알고리즘05-8](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-8.png)

![알고리즘05-9](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-9.png)

![알고리즘05-10](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-10.png)

![알고리즘05-11](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-11.png)

![알고리즘05-12](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-12.png)

![알고리즘05-13](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-13.png)

![알고리즘05-14](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-14.png)

![알고리즘05-15](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-15.png)

![알고리즘05-16](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-16.png)

![알고리즘05-17](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-17.png)

![알고리즘05-18](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-18.png)

![알고리즘05-19](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-19.png)

![알고리즘05-20](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-20.png)

![알고리즘05-21](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-21.png)

![알고리즘05-22](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-22.png)

![알고리즘05-23](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-23.png)

![알고리즘05-24](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-24.png)

![알고리즘05-25](/python/images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9805-25.png)



## DFS의 구현 방식



#### 반복문을 이용한 DFS

- DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 스택을 사용한다.

```python
# 먼저 인접 리스트를 생성
n = int(input()) # 정점 개수
n = int(input()) # 간선 개수
graph [[]for _ in range(n+1)]
visited = [False] * (n + 1)
total = 0

# 인접 리스트 만들기
for _ in range(m):
  	v1, v2 = map(int, input().split())
    graph[v1].append(v2)
    graph[v2].append(v1)

visited = [False] * n # 방문 처리 리스트 만들기

def dfs(start):
  	stack = [start] # 돌아갈 곳을 기록
    visited[start] = True # 시작 정점 방문 처리
    
    while stack: # 스택이 빌 때까지(돌아갈 곳이 없을 때까지) 반복
      	cur = stack.pop() # 현재 방문 정점(후입선출)
        
        for adj in graph[cur]: # 인접한 모든 정점에 대해
          	if not visited[adj]: # 아직 방문하지 않았다면
              	visited[adj] = True # 방문 처리
                stack.append(adj) # 스택에 넣기
dfs(0) # 0번 정점에서 시작
```

