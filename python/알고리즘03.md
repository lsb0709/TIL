# 완전탐색 1 (Exhaustive Search)



## 무식하게 다해보기(Brute-force)



#### Brute-force는 모든 경우의 수를 탐색하여 문제를 해결하는 방식이다.

- 브루트포스(Brute-force)라고도 하며, 무식하게 밀어붙인다는 뜻이다.
- 가장 단순한 풀이 기법이며, 단순 조건문과 반복문을 이용해서 풀 수 있다.
- 복잡한 알고리즘 보다는, 아이디어를 어떻게 코드로 구현할 것인지가 중요하다.



#### 블랙잭 문제를 통해 Brute-force 이해하기



##### BOJ 2798 블랙잭

카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 

블랙잭은 카지노마다 다양한 규정이 있다.

한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.

김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 

그런 후에 딜러는 숫자 M을 크게 외친다.

이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 

플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.

N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.



입력

첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 

이 값은 100,000을 넘지 않는 양의 정수이다.

합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.



출력

첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.



5장의 카드 5,6,7,8,9 중 세 장의 카드의 합(max_total)이 21이 넘지 않아야 한다.



```python
def blackjack(n, m, cards):
  	max_total = 0 # 현재 가장 큰 합
    
    # 완전탐색(Brute-force)
    for i in range(n - 2):
      	for j in range(j + 1, n - 1):
          	for k in range(j + 1, n):
              	total = cards[i] + cards[j] + cards[k]
                
                # 현재 가장 큰 합보다는 크고, m을 넘지 않아야 갱신
                if max_total < total <= m:
                  	max_total = total
                
                # 합과 m이 같으면 더이상 탐색하는 의미가 없으므로 종료
                if total == m:
                  	return total
    return max_total
  
print(blackjack(n, m, cards))  
```



- 3중 for문을 이용해 모든 경우의 수를 탐색
- i, j, k는 세 장의 카드의 인덱스를 의미
- 중복으로 뽑는 경우를 방지하기 위해 range 범위



## 델타 탐색(Delta Search)

- 지금까지는 모든 경우의 수를 따지는 일반적인 완전탐색을 알아보았다.
- 이차원 리스트의 완전탐색에서 많이 등장하는 유형인 델타 탐색(상하좌우 탐색)을 알아보자.

| 1 (0, 0) | 2 (0, 1) | 3 (0, 2) |
| :------: | :------: | :------: |
| 4 (1, 0) | 5 (1, 1) | 6 (1, 2) |
| 7 (2, 0) | 8 (2, 1) | 9 (2, 2) |

- (0, 0)에서부터 이차원 리스트의 모든 원소를 순회하며(완전탐색)
- 각 지점에서 상하좌우에 위치한 다른 지점을 조회하거나 이동하는 방식이다.
- 이차원 리스트의 인덱스(좌표)의 조작을 통해서 상하좌우 탐색을 한다
  - 이 때 행과 열의 변량인 -1, +1을 델타(delta)값이라고 한다.



```python
# 1) 행을 x, 열을 y로 표현
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
		 [상, 하, 좌, 우] (세로로)

# 상(x - 1, y)
nx = x + dx[0]
ny = y + dy[0]

# 하(x + 1, y)
nx = x + dx[1]
ny = y + dy[1]

# 좌(x, y - 1)
nx = x + dx[2]
ny = y + dy[2]

# 우(x, y + 1)
nx = x + dx[3]
ny = y + dy[3]

# 상하좌우
for i in range(4):
  	nx = x + dx[i]
    ny = y + dy[i]
    # for 문을 이용한 상하좌우 이동표현
```



```python
# 상하좌우로 이동 후 범위를 벗어나지 않는지 확인 및 갱신하기

# 1. 델타값을 이용해 상하좌우 이동
for i in rnage(4):
  	nx = x + dx[i]
    ny = y + dy[i]
    
		# 2. 범위를 벗어나지 않으면 갱신
		if 0 <= nx < 3 and 0 <= ny < 3:
      	x = nx
        y = ny
        # 범위 바깥 부분을 제외시켜주기 위해 if함수를 추가시켜 준다.
```



```python
# 이차원 리스트의 상하좌우 탐색 정리

# 1. 델타값 정의(상하좌우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 2. 이차원 리스트 순회
for x in range(n):
		for y in range(m):
      
      	# 3. 델타값을 이용해 상하좌우 이동
        for i in range(4):
          	nx = x + dx[i]
            ny = y + dy[i]
            
            # 4. 범위를 벗어나지 않으면 갱신
            if 0 <= nx < n and 0 <= ny < m:
              	x = nx
                y = ny
```



[참고] 상하좌우 + 대각선의 8방향 델타 값

```python
# 상 하 좌 우 좌상 좌하 우상 우하
dx = [-1, 1, 0, 0, -1, 1, -1, 1]
dy = [0, 0, -1, 1, -1, -1, 1, 1]
```

